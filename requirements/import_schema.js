/**
 * Import PocketBase collections schema from JSON file
 * This script will:
 * - Only create/update collections defined in the schema file
 * - NOT delete existing collections that are not in the file
 * - Preserve all other collections in your PocketBase instance
 *
 * Run:
 * PB_URL="http://127.0.0.1:8090" \
 * PB_EMAIL="admin@example.com" \
 * PB_PASSWORD="your_password" \
 * node requirements/import_schema.js [path/to/schema.json]
 */

import PocketBase from "pocketbase";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { PB_CONFIG } from "../src/config/pb.config.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Get schema file path from command line or use default
const schemaFile = process.argv[2] || path.join(__dirname, "..", "pb_schema_ticket.json");

if (!fs.existsSync(schemaFile)) {
  console.error(`[FAIL] Schema file not found: ${schemaFile}`);
  process.exit(1);
}

// Normalize field definition for PocketBase API
function normalizeField(field, collectionIdMap = {}) {
  // Skip system fields - PocketBase creates these automatically
  // id, created, updated are auto-generated by PocketBase
  if (field.system === true || 
      field.name === "id" || 
      field.name === "created" || 
      field.name === "updated") {
    return null; // Will be filtered out
  }

  const normalized = {
    name: field.name,
    type: field.type,
  };

  // Only include properties that are explicitly set or have meaningful defaults
  if (field.required !== undefined) normalized.required = field.required;
  if (field.presentable !== undefined) normalized.presentable = field.presentable;
  if (field.hidden === true) normalized.hidden = true;

  // PocketBase API requires type-specific options to be in an "options" object
  const options = {};

  // Type-specific properties
  switch (field.type) {
    case "text":
      // Don't include primaryKey - PocketBase handles id field automatically
      // Only include min/max if they are > 0 (0 means unlimited in PocketBase) - put in options
      if (field.min !== undefined && field.min !== null && field.min > 0) options.min = field.min;
      if (field.max !== undefined && field.max !== null && field.max > 0) options.max = field.max;
      if (field.pattern && field.pattern !== "") options.pattern = field.pattern;
      if (field.autogeneratePattern && field.autogeneratePattern !== "") options.autogeneratePattern = field.autogeneratePattern;
      break;

    case "select":
      // maxSelect and values are required for select fields - put in options
      options.maxSelect = field.maxSelect !== undefined && field.maxSelect !== null ? field.maxSelect : 1;
      options.values = field.values && Array.isArray(field.values) ? field.values : [];
      break;

    case "relation":
      // Map old collectionId to new collectionId if available - put in options
      if (collectionIdMap[field.collectionId]) {
        options.collectionId = collectionIdMap[field.collectionId];
      } else if (field.collectionId) {
        // If not in map, try to use the original ID (might work if collection exists)
        options.collectionId = field.collectionId;
      } else {
        console.warn(`[WARN] Relation field ${field.name} has no collectionId, skipping...`);
        return null; // Skip this field if no collectionId
      }
      options.maxSelect = field.maxSelect !== undefined && field.maxSelect !== null ? field.maxSelect : 1;
      if (field.minSelect !== undefined && field.minSelect !== null) options.minSelect = field.minSelect;
      if (field.cascadeDelete !== undefined) options.cascadeDelete = field.cascadeDelete;
      break;

    case "editor":
      if (field.maxSize !== undefined && field.maxSize !== null && field.maxSize > 0) options.maxSize = field.maxSize;
      if (field.convertURLs !== undefined) options.convertURLs = field.convertURLs;
      break;

    case "file":
      // maxSelect and maxSize are required for file fields - put in options
      // maxSize cannot be 0 or null - use a large number for "unlimited"
      options.maxSelect = field.maxSelect !== undefined && field.maxSelect !== null ? field.maxSelect : 1;
      options.maxSize = field.maxSize !== undefined && field.maxSize !== null && field.maxSize > 0 
        ? field.maxSize 
        : 52428800; // Default to 50MB if not specified (0 means unlimited in schema, but API requires a value)
      if (field.mimeTypes && Array.isArray(field.mimeTypes) && field.mimeTypes.length > 0) options.mimeTypes = field.mimeTypes;
      if (field.thumbs && Array.isArray(field.thumbs) && field.thumbs.length > 0) options.thumbs = field.thumbs;
      if (field.protected !== undefined) options.protected = field.protected;
      break;

    case "date":
      if (field.min && field.min !== "") options.min = field.min;
      if (field.max && field.max !== "") options.max = field.max;
      break;

    case "autodate":
      options.onCreate = field.onCreate || false;
      options.onUpdate = field.onUpdate || false;
      break;
  }

  // Only add options if it has properties
  if (Object.keys(options).length > 0) {
    normalized.options = options;
  }

  return normalized;
}

// Normalize collection definition
function normalizeCollection(collection, collectionIdMap = {}) {
  // Filter out null fields (system fields that were skipped)
  const schema = collection.fields
    .map(field => normalizeField(field, collectionIdMap))
    .filter(field => field !== null);

  return {
    name: collection.name,
    type: collection.type || "base",
    schema: schema,
    indexes: collection.indexes || [],
    listRule: collection.listRule || null,
    viewRule: collection.viewRule || null,
    createRule: collection.createRule || null,
    updateRule: collection.updateRule || null,
    deleteRule: collection.deleteRule || null,
  };
}

async function main() {
  console.log(`[INFO] Reading schema from: ${schemaFile}`);
  const schemaData = JSON.parse(fs.readFileSync(schemaFile, "utf-8"));
  
  if (!Array.isArray(schemaData)) {
    console.error("[FAIL] Schema file must contain an array of collections");
    process.exit(1);
  }

  // Ensure URL doesn't have trailing slash
  const pbUrl = PB_CONFIG.URL.replace(/\/$/, "");
  const pb = new PocketBase(pbUrl);

  // ---- Admin auth
  // Try SDK first, fallback to direct fetch if SDK fails
  let authSuccess = false;
  try {
    await pb.admins.authWithPassword(PB_CONFIG.EMAIL, PB_CONFIG.PASSWORD);
    console.log("[OK] Admin authenticated (SDK)");
    authSuccess = true;
  } catch (e) {
    console.log("[WARN] SDK auth failed, trying direct fetch...");
    try {
      // Fallback: use direct fetch for admin auth
      const authUrl = `${pbUrl}/api/admins/auth-with-password`;
      const response = await fetch(authUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          identity: PB_CONFIG.EMAIL,
          password: PB_CONFIG.PASSWORD,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || `HTTP ${response.status}`);
      }

      const authData = await response.json();
      
      // Manually set the auth token in SDK
      pb.authStore.save(authData.token, authData.record);
      console.log("[OK] Admin authenticated (direct fetch)");
      authSuccess = true;
    } catch (fetchError) {
      console.error("[FAIL] Admin auth failed (both methods)");
      console.error("SDK error:", e?.data || e?.message);
      console.error("Fetch error:", fetchError?.message || fetchError);
      process.exit(1);
    }
  }

  // ---- Get existing collections
  const existingCollections = await pb.collections.getFullList();
  const existingMap = new Map(existingCollections.map(c => [c.name, c]));
  const existingIds = new Map(existingCollections.map(c => [c.name, c.id]));
  
  // Create a map from old collectionId (from schema) to new collectionId (from existing or newly created)
  // This helps resolve relation fields that reference other collections
  const collectionIdMap = {};
  for (const collectionDef of schemaData) {
    const oldId = collectionDef.id;
    const collectionName = collectionDef.name;
    if (existingMap.has(collectionName)) {
      collectionIdMap[oldId] = existingIds.get(collectionName);
    }
  }

  console.log(`[INFO] Found ${existingCollections.length} existing collections`);
  console.log(`[INFO] Will import ${schemaData.length} collections from schema`);

  // ---- Process each collection in schema
  // First pass: create collections without relation fields (to avoid dependency issues)
  const createdCollections = new Map();
  const collectionsToUpdate = [];
  
  for (const collectionDef of schemaData) {
    const collectionName = collectionDef.name;
    const oldId = collectionDef.id;

    try {
      if (existingMap.has(collectionName)) {
        // Collection exists - just update the ID map
        const existingId = existingIds.get(collectionName);
        collectionIdMap[oldId] = existingId;
        collectionsToUpdate.push({ collectionDef, collectionId: existingId, isNew: false });
      } else {
        // Collection doesn't exist - create it without relation fields first
        console.log(`[INFO] Creating collection: ${collectionName}`);
        
        // Create collection with schema excluding relation fields
        const fieldsWithoutRelations = collectionDef.fields.filter(f => f.type !== "relation");
        const tempCollection = {
          ...collectionDef,
          fields: fieldsWithoutRelations
        };
        const normalized = normalizeCollection(tempCollection, collectionIdMap);
        
        // Debug: log the payload
        if (process.env.DEBUG) {
          console.log(`[DEBUG] Payload for ${collectionName}:`, JSON.stringify(normalized, null, 2));
        }
        
        try {
          const created = await pb.collections.create(normalized);
          collectionIdMap[oldId] = created.id;
          createdCollections.set(collectionName, created.id);
          collectionsToUpdate.push({ collectionDef, collectionId: created.id, isNew: true });
          
          console.log(`[OK]   Created: ${collectionName} (${created.id})`);
        } catch (createError) {
          // If SDK fails, try direct fetch
          console.log(`[WARN] SDK create failed, trying direct fetch...`);
          try {
            const createUrl = `${pbUrl}/api/collections`;
            const token = pb.authStore.token;
            const response = await fetch(createUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": token ? `Bearer ${token}` : "",
              },
              body: JSON.stringify(normalized),
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              throw new Error(errorData.message || `HTTP ${response.status}`);
            }

            const created = await response.json();
            collectionIdMap[oldId] = created.id;
            createdCollections.set(collectionName, created.id);
            collectionsToUpdate.push({ collectionDef, collectionId: created.id, isNew: true });
            
            console.log(`[OK]   Created: ${collectionName} (${created.id}) via direct fetch`);
          } catch (fetchError) {
            throw createError; // Throw original error
          }
        }
      }
    } catch (error) {
      console.error(`[FAIL] Error processing ${collectionName}:`);
      console.error(`       ${error?.message || error}`);
      if (error?.data) {
        console.error(`       Data:`, JSON.stringify(error.data, null, 2));
      }
      // Continue with next collection instead of exiting
    }
  }

  // Second pass: update all collections with full schema including relation fields
  if (collectionsToUpdate.length > 0) {
    console.log(`\n[INFO] Updating collections with full schema (including relations)...`);
    for (const { collectionDef, collectionId, isNew } of collectionsToUpdate) {
      try {
        const normalized = normalizeCollection(collectionDef, collectionIdMap);
        await pb.collections.update(collectionId, normalized);
        console.log(`[OK]   ${isNew ? 'Updated' : 'Updated'}: ${collectionDef.name}`);
      } catch (error) {
        console.error(`[WARN] Could not update ${collectionDef.name}: ${error?.message}`);
        if (error?.data) {
          console.error(`       Data:`, JSON.stringify(error.data, null, 2));
        }
      }
    }
  }

  console.log("\n[DONE] Schema import completed!");
  console.log("[NOTE] Existing collections not in schema file were preserved.");
}

main().catch((err) => {
  console.error("[FATAL]", err);
  process.exit(1);
});
